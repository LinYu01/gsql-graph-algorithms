CREATE QUERY tg_ann(INT k, STRING v_type, STRING sim_type, STRING sim_edge, INT max_iters, BOOL print_accum)  {
  TYPEDEF TUPLE<node VERTEX, similarity DOUBLE> info;
  Typedef HeapAccum<info>(k, similarity DESC) approximate_nn;
  HeapAccum<info>(k, similarity ASC) @approximate_nn_reverse;
  MapAccum<VERTEX, ListAccum<DOUBLE>> @@feature_map;
  GroupByAccum<VERTEX v, approximate_nn nn_heap> @@approximate_nn_map;
  ListAccum<VERTEX> @@random_samples;
  SumAccum<INT> @@c;
  
  Start = {v_type.*};

  Init =
    SELECT s FROM Start:s
    ACCUM @@random_samples += s;
  
  WHILE TRUE LIMIT k DO
    RandomSelect =
      SELECT s FROM Start:s
      ACCUM
        @@feature_map += (s -> s.listAttr) // REPLACE WITH VALID LIST ATTRIBUTE
      POST-ACCUM
        VERTEX v = @@random_samples.get(rand_int(0, @@random_samples.size())),
        IF v != s THEN
          @@approximate_nn_map += (s -> info(v, similarity_UDF(@@feature_map.get(s), @@feature_map.get(v), simType)))
        END;
  END;
  
  @@random_samples.clear();

  WHILE TRUE LIMIT max_iters DO
    @@c = 0;
    preprocessing 
      = SELECT s FROM Start:s
      ACCUM
        FOREACH info_t in @@approximate_nn_map.get(s).nn_heap DO
          @@approximate_nn_map += (info_t.node -> info(s, info_t.similarity))
        END
      POST-ACCUM
        FOREACH info_t in @@approximate_nn_map.get(s).nn_heap DO
          s.@approximate_nn_reverse += info_t
        END;

    processing = 
      SELECT s FROM Start:s
      POST-ACCUM
        FOREACH info_t1 in @@approximate_nn_map.get(s).nn_heap DO
          FOREACH info_t2 in @@approximate_nn_map.get(info_t1.node).nn_heap DO
            DOUBLE l = similarity_UDF(@@feature_map.get(s), @@feature_map.get(info_t2.node), simType), // any of the similarity UDFs
            IF s.@approximate_nn_reverse.size() < k THEN
              @@approximate_nn_map += (s -> info(info_t2.node, l)),
              s.@approximate_nn_reverse += info(info_t2.node, l),
              @@c += 1
            ELSE IF l > s.@approximate_nn_reverse.top().similarity THEN
              @@approximate_nn_map += (s -> info(info_t2.node, l)),
              s.@approximate_nn_reverse.pop(),
              s.@approximate_nn_reverse += info(info_t2.node, l),
              @@c += 1
            END
          END
        END,
        s.@approximate_nn_reverse.clear();
  
    IF @@c == 0 THEN BREAK; END;
  END;
  
  IF sim_edge != "" THEN
    Start =
      SELECT s FROM Start:s
      POST-ACCUM
        FOREACH info_tup IN @@approximate_nn_map.get(s) DO
          INSERT INTO sim_edge VALUES (s, info_tup.node, info_tup.similarity)
        END;
  END;
  
  IF print_accum THEN
    PRINT Start;
  END;
}
