CREATE QUERY tg_louvain_distributed(SET<STRING> v_type, SET<STRING> e_type, STRING wt_attr, INT max_iter = 10, FLOAT tolerence = 0.0001,
    BOOL intermediate_result = FALSE, BOOL print_accum = FALSE, STRING result_attr = "", STRING file_path = "") {

/*
Distributed version louvain community detection algorithm
Parameters:
v_type: vertex types to traverse
e_type: edge types to traverse
wt_attr: attribute name for edge weights
         wt_attr type is hardcoded to FLOAT
		 INT or DOUBLE can be supported by changing "FLOAT" to "INT"/"DOUBLE" (~10 instances) below
max_iter: maximum iteration of louvain optimization
tolerence: deltaQ tolerence for terminating louvain optimization
intermediateResult: save intermediate results
print_accum: print accumulator JSON
result_attr: attribute name to assign community results to
file_path: file path to write CSV output to
*/

TYPEDEF TUPLE <FLOAT deltaQ, FLOAT weight, VERTEX cc> move; 
SumAccum<FLOAT> @sum_ac; #sum of the degrees of all the vertices in community C of the vertex
ListAccum<VERTEX> @cc_list; #the community center
SumAccum<FLOAT> @sum_weight; # total weight incident to this vertex
SumAccum<FLOAT> @sum_cc_weight; # total weight incident to the cc vertex
MapAccum<VERTEX,SumAccum<FLOAT>> @A_map; #A[c]: sum of the edge weights for the edges in community c
MaxAccum<move> @max_best_move; # highest dQ, highest -Outdegree, highest cc
ListAccum<VERTEX> @cm_list;  #community member list
SumAccum<FLOAT> @@sum_m; # total edge weight
ListAccum<INT> @cc_intermediate_list;
OrAccum<BOOL> @@or_cc_change;
FILE f (file_path);

Start = {v_type}; 
	
// initialize
Start = SELECT s 
        FROM Start:s-(e_type:e)->:t 
        ACCUM 
	    @@sum_m += e.getAttr(wt_attr,"FLOAT")*0.5,
	    s.@sum_weight += e.getAttr(wt_attr,"FLOAT")*1.0,
	    s.@sum_cc_weight += e.getAttr(wt_attr,"FLOAT")*1.0
	POST-ACCUM 
	    s.@cc_list += s,
	    IF intermediate_result THEN 
	        s.@cc_intermediate_list += getvid(s) 
	    END;

// special @cc update in the first iteration
Start = SELECT t 
	FROM Start:s-(e_type:e)->:t
        ACCUM
            t.@max_best_move += move(e.getAttr(wt_attr,"FLOAT")*1.0 + 
            @@sum_m*t.@sum_weight * (t.@sum_weight - s.@sum_weight), 
	    -s.@sum_cc_weight, s.@cc_list.get(0))
	POST-ACCUM
	    IF getDeltaQ(t.@max_best_move) > 0 THEN
	        IF -getWeight(t.@max_best_move) < t.@sum_cc_weight THEN  //
	            t.@cc_list.clear(), 
		    t.@cc_list += getCc(t.@max_best_move),
	            t.@sum_cc_weight = -getWeight(t.@max_best_move),
		    @@or_cc_change += TRUE
	        ELSE 
		    IF -getWeight(t.@max_best_move) == t.@sum_cc_weight AND getvid(t) < getvid(getCc(t.@max_best_move))  THEN
		        t.@cc_list.clear(),
		        t.@cc_list += getCc(t.@max_best_move),
		        t.@sum_cc_weight = -getWeight(t.@max_best_move),
		        @@or_cc_change += TRUE
		    END
	        END
	    END,
	    IF intermediate_result THEN 
	        t.@cc_intermediate_list += getvid(t.@cc_list.get(0)) 
	    END;
  
// main loop
WHILE @@or_cc_change LIMIT max_iter DO
// initialize for iteration
    @@or_cc_change = FALSE;
    Start = SELECT s 
            FROM Start:s 
	    POST-ACCUM 
	        s.@sum_ac = 0,
		s.@cm_list.clear(),
		s.@A_map.clear();

    Start = SELECT s 
	    FROM Start:s 
	    ACCUM 
	        FOREACH v IN s.@cc_list DO
	            CASE WHEN getvid(v) != -1 THEN 
		        v.@cm_list += s 
		    END
	        END;

    Start = SELECT s 
            FROM Start:s-(e_type:e)->:t 
	    ACCUM 
	        s.@A_map += (t.@cc_list.get(0)->1);
		
    Start = SELECT s 
            FROM Start:s 
	    ACCUM 
	        FOREACH v IN s.@cc_list DO
		    CASE WHEN getvid(v) != -1 THEN 
		        v.@sum_ac += s.@sum_weight 
		    END
		END;

    Start = SELECT s 
            FROM Start:s 
	    ACCUM 
	        FOREACH v IN s.@cm_list DO
		    CASE WHEN getvid(v) != -1 THEN 
		        v.@sum_ac = s.@sum_ac 
		    END
	        END;

    // compute @max_dQ
    Start = SELECT s 
            FROM Start:s-(e_type:e)->:t
	    ACCUM
	        INT A_s = 0,
		IF s.@A_map.containsKey(s) THEN
	            A_s = s.@A_map.get(s)
		END,
		s.@max_best_move += move(s.@A_map.get(t.@cc_list.get(0)) - A_s + 
		1/@@sum_m*s.@sum_weight*(s.@sum_ac-t.@sum_ac), 
		-t.@sum_cc_weight, t.@cc_list.get(0))
		
	    POST-ACCUM
	        IF getDeltaQ(s.@max_best_move) > 0 THEN
		    IF -getWeight(s.@max_best_move) < s.@sum_cc_weight THEN
		        s.@cc_list.clear(),
			s.@cc_list += getCc(s.@max_best_move),
			s.@sum_cc_weight = -getWeight(s.@max_best_move),
			@@or_cc_change += TRUE
		    ELSE 
		        IF -getWeight(s.@max_best_move) == s.@sum_cc_weight AND getvid(s.@cc_list.get(0)) < getvid(getCc(s.@max_best_move))  THEN
			    s.@cc_list.clear(),
			    s.@cc_list += getCc(s.@max_best_move),
			    s.@sum_cc_weight = -getWeight(s.@max_best_move),
			    @@or_cc_change += TRUE
			END
		    END
		END,
		IF intermediate_result THEN 
		    s.@cc_intermediate_list += getvid(s.@cc_list.get(0)) 
		END;
END;

// save and print result
Start = SELECT s 
        FROM Start:s
	POST-ACCUM
        IF result_attr != "" THEN 
	    s.setAttr(result_attr, getvid(s.@cc_list.get(0))) 
	END,
	IF file_path != "" THEN
            IF intermediate_result THEN
	        f.println(s, getvid(s.@cc_list.get(0)), s.@cc_intermediate_list)
	    ELSE
		f.println(s, getvid(s.@cc_list.get(0)))
	    END
	END;
IF print_accum THEN
    IF intermediate_result THEN
        PRINT Start [Start.@cc_list.get(0), Start.@cc_intermediate_list];
    ELSE
	PRINT Start [Start.@cc_list.get(0)];
    END;
END;
}
