CREATE QUERY tg_resource_allocation(VERTEX a, VERTEX b, SET<STRING> e_type){ 
  /*
    This query calculates the resource allocation value between two vertices.
    Higher the number, the closer two vertices are. A 0 value indicates two vertices are not close.

    Further detail of caluclation is found here: https://arxiv.org/abs/0901.0553

    Parameters :
      a : Input vertex one
      b : Input vertex two
      e_type: edge types to traverse. If none are defined, then all edge types will be used.
  */
  SumAccum<INT> @numNeighbors;
  SumAccum<DOUBLE> @@closeness;
  avs = {a};
  bvs = {b};
  
  // See if user specified edge types to traverse
  IF e_type.size() != 0 THEN
    // Get Neighbors in Common
    na = SELECT n FROM avs -(e_type)-> :n;  // Get vertex A's neighbors 
    nb = SELECT n FROM bvs -(e_type)-> :n;  // Get vertex B's neighbors 
    u = na INTERSECT nb;  // Get neighbors in common 
    tmp = SELECT p FROM u:p -(e_type)- :r ACCUM p.@numNeighbors += 1;  // count number of neighbors of in-common vertices
  ELSE  // traverse all edge types
    na = SELECT n FROM avs -()-> :n;  // Get vertex A's neighbors 
    nb = SELECT n FROM bvs -()-> :n;  // Get vertex B's neighbors 
    u = na INTERSECT nb;  // Get neighbors in common 
    tmp = SELECT p FROM u:p -()- :r ACCUM p.@numNeighbors += 1;  // count number of neighbors of in-common vertices
  END;
  res = SELECT p FROM tmp:p ACCUM @@closeness += 1/p.@numNeighbors;  // calculates closeness measure
  
  PRINT @@closeness; 
}